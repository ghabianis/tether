#+title: Todo

* TODO Now [5/12]
** DONE don't render spaces/tabs/newlines (any empty height or width glyphs)
** DONE fix backspace on newline
** DONE Vim [0/0]
*** DONE support =Key= and not just chars (change CharParser to KeyParser)
*** DONE support delete/change/yank + movement
*** DONE support w/W/b/B/e/E [0/0]
**** DONE w/W
**** DONE b/B
**** DONE e/E
** TODO LIGATURES! [3/5]
I want them juicy sexy ligatures

Ideally, I get ligature info from the CoreText API, and I just need to modify existing code to detect when a sequence of chars is
a ligature, and then render them.

But I couldn't find anything in the CoreText API.

I did find a way with =CTRun= (See the diagram [[https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Overview/Overview.html#//apple_ref/doc/uid/TP40005533-CH3-SW1][here]] for the architecture of CoreText objects)

CTRun is a "run" of glyphs, and =CTRunGetPositions= gives you the positions for each glyph, which includes ligature glyphs (I'm pretty sure).

So instead of rendering glyphs one by one as we are now, we need to group them into CTRuns, probably line by line. This probably good anyway, because
the set of glyphs the set of characters are not isomorphic.

With my Iosevka font, I tried to output the glyph for the ligature "=>". It actually gave me two special ligature glyphs, one for each component (the two horizontal lines and the arrow).

*** DONE first write a benchmark for current text geometry building to prevent regressions
*** DONE add common font ligatures to atlas at beginning
*** DONE refactor text geometry building to use CTRun [0/0]
**** DONE iterate line by line
**** DONE efficiently create attributed string for line [0/0]
***** DONE create NSString zero-copy with =initWithBytesNoCopy:length:freeWhenDone:=
***** DONE make the attributed string with =initWithString:attributes:=
***** DONE make the attributes NSDictionary once, and cache it (probably at startup)
**** DONE create line =ct.CTLineCreateWithAttributedString(attributed_string)=
**** DONE get CTRun positions/glyphs
**** DONE convert positions/glyphs -> Vertices
*** TODO refactor cursor/selection geometry
will this be performant enough?

if not this might require using the full CoreText API (=CTLine=, =CTFrame=)
*** TODO add new ligatures to atlas when encountered
easiest to rebuild atlas from scratch again

** DONE bug: delete/change range broken
cause I added `self.len -= node.data.items.len;` to Rope.remove_node() and this fucks up Rope.remove_text() because it is already doing the calculation
need to make separate functions: one that subtracts len and one that doesn't
** DONE bug: paste broken
try pasting this into empty editor:
#+begin_src zig
fn fuck(self: *Self) void {
    _ = self;
}
#+end_src
** TODO bug: word breaking with punctuation detection for w/W/e/E/b/B
Word breaking rules are fucked.

Word can break in 3 cases:
- when whitespace is encountered
- when punctuation is encountered IF the word is comprised of NON-punctuation characters
- whenn non-punctuation is encountered IF the word is comprised of punctuation characters

This means there are two types of words, those comprised of punctuation characters, and those that dont!

For example:
#+begin_src
fuck+++yay!
#+end_src
with the cursor on the first =+=, pressing =w= should bring the cursor the first =y=. instead it goes to the next =+=.

Another case
#+begin_src zig
fn fuck(self: *Self) void {

}
#+end_src
With cursor on =k=, pressing =E= should go to =(= but instead goes to end of =self=.

** TODO moving up/down/creating lines preserves word column when possible
example:
#+begin_src zig
pub fn start_of_line(self: *Self) void {
    self.cursor.col = 0;
    self.draw_text = true;
}
#+end_src

if cursor is at =s= in =start_of_line= (index 7)

when going down, cursor will try to be on index 7 if possible, if not then the greatest char possible
** TODO bug: semicolon texture fucked up
if you look at the atlas, the =)= glyph is intersecting with the =;= glyph.
** TODO bug: delete/change move still not correct
ex: de or ce on this text with cursor at 0:
#+begin_src
self nice
#+end_src

remainder should be:
#+begin_src
 nice
#+end_src

instead is:
#+begin_src
f nice
#+end_src
** TODO bug: =cc= (change line) should preserve line and not delete it entirely
* TODO Later [0/4]
** TODO event loop or some mechanism to do work without stalling frame
** TODO create deinit function for renderer/editor
** TODO Egui for debugging?
** TODO curves svg etc
* Archive
** DONE Fix cursor [0/0]
*** DONE not in front of text
*** DONE newline fucks it up
** DONE next line is not starting at the right Y
we use =max_glyph_h= as the Y advance
but this is not correct
it needs to take into account glyphs that have their y origin lower
for example in the glyph 'y'
i think this might be the 'descent' font metric
